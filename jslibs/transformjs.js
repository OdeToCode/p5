// ==========================================================================
// Project:   TransformJS - CSSHooks for 2D and 3D Transforms
// Copyright: Â©2006-2011 Strobe Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================

// Vector and Matrix mathematics modules for JavaScript
// Copyright (c) 2007 James Coglan
// 
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
function Matrix() { } var Sylvester = { version: "0.1.3", precision: 1e-6 }; Matrix.prototype = { e: function (a, b) { return a < 1 || a > this.elements.length || b < 1 || b > this.elements[0].length ? null : this.elements[a - 1][b - 1] }, map: function (a) { var b = [], c = this.elements.length, d = c, e, f, g = this.elements[0].length, h; do { e = d - c, f = g, b[e] = []; do h = g - f, b[e][h] = a(this.elements[e][h], e + 1, h + 1); while (--f) } while (--c); return Matrix.create(b) }, multiply: function (a) { if (!a.elements) return this.map(function (b) { return b * a }); var b = a.modulus ? !0 : !1, c = a.elements || a; typeof c[0][0] == "undefined" && (c = Matrix.create(c).elements); if (!this.canMultiplyFromLeft(c)) return null; var d = this.elements.length, e = d, f, g, h = c[0].length, i, j = this.elements[0].length, k = [], l, m, n; do { f = e - d, k[f] = [], g = h; do { i = h - g, l = 0, m = j; do n = j - m, l += this.elements[f][n] * c[n][i]; while (--m); k[f][i] = l } while (--g) } while (--d); var c = Matrix.create(k); return b ? c.col(1) : c }, x: function (a) { return this.multiply(a) }, canMultiplyFromLeft: function (a) { var b = a.elements || a; return typeof b[0][0] == "undefined" && (b = Matrix.create(b).elements), this.elements[0].length == b.length }, setElements: function (a) { var b, c = a.elements || a; if (typeof c[0][0] != "undefined") { var d = c.length, e = d, f, g, h; this.elements = []; do { b = e - d, f = c[b].length, g = f, this.elements[b] = []; do h = g - f, this.elements[b][h] = c[b][h]; while (--f) } while (--d); return this } var i = c.length, j = i; this.elements = []; do b = j - i, this.elements.push([c[b]]); while (--i); return this } }, Matrix.create = function (a) { var b = new Matrix; return b.setElements(a) }, $M = Matrix.create, function (a) { if (!a.cssHooks) throw "jQuery 1.4.3+ is needed for this plugin to work"; var b = "transform", c, d, e, f, g, h = b.charAt(0).toUpperCase() + b.slice(1), i = ["Moz", "Webkit", "O", "MS"], j = document.createElement("div"); if (b in j.style) d = b, e = j.style.perspective !== undefined; else for (var k = 0; k < i.length; k++) { c = i[k] + h; if (c in j.style) { d = c, i[k] + "Perspective" in j.style ? e = !0 : f = !0; break } } d || (g = "filter" in j.style, d = "filter"), j = null, a.support[b] = d; var l = d, m = { rotateX: { defaultValue: 0, matrix: function (a) { return e ? $M([[1, 0, 0, 0], [0, Math.cos(a), Math.sin(-a), 0], [0, Math.sin(a), Math.cos(a), 0], [0, 0, 0, 1]]) : $M([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) } }, rotateY: { defaultValue: 0, matrix: function (a) { return e ? $M([[Math.cos(a), 0, Math.sin(a), 0], [0, 1, 0, 0], [Math.sin(-a), 0, Math.cos(a), 0], [0, 0, 0, 1]]) : $M([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) } }, rotateZ: { defaultValue: 0, matrix: function (a) { return e ? $M([[Math.cos(a), Math.sin(-a), 0, 0], [Math.sin(a), Math.cos(a), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) : $M([[Math.cos(a), Math.sin(-a), 0], [Math.sin(a), Math.cos(a), 0], [0, 0, 1]]) } }, scale: { defaultValue: 1, matrix: function (a) { return e ? $M([[a, 0, 0, 0], [0, a, 0, 0], [0, 0, a, 0], [0, 0, 0, 1]]) : $M([[a, 0, 0], [0, a, 0], [0, 0, 1]]) } }, translateX: { defaultValue: 0, matrix: function (a) { return e ? $M([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [a, 0, 0, 1]]) : $M([[1, 0, 0], [0, 1, 0], [a, 0, 1]]) } }, translateY: { defaultValue: 0, matrix: function (a) { return e ? $M([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, a, 0, 1]]) : $M([[1, 0, 0], [0, 1, 0], [0, a, 1]]) } }, translateZ: { defaultValue: 0, matrix: function (a) { return e ? $M([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, a, 1]]) : $M([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) } } }, n = function (b) { var c = a(b).data("transforms"), d; e ? d = $M([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) : d = $M([[1, 0, 0], [0, 1, 0], [0, 0, 1]]); for (var h in m) d = d.x(m[h].matrix(c[h] || m[h].defaultValue)); e ? (s = "matrix3d(", s += d.e(1, 1).toFixed(10) + "," + d.e(1, 2).toFixed(10) + "," + d.e(1, 3).toFixed(10) + "," + d.e(1, 4).toFixed(10) + ",", s += d.e(2, 1).toFixed(10) + "," + d.e(2, 2).toFixed(10) + "," + d.e(2, 3).toFixed(10) + "," + d.e(2, 4).toFixed(10) + ",", s += d.e(3, 1).toFixed(10) + "," + d.e(3, 2).toFixed(10) + "," + d.e(3, 3).toFixed(10) + "," + d.e(3, 4).toFixed(10) + ",", s += d.e(4, 1).toFixed(10) + "," + d.e(4, 2).toFixed(10) + "," + d.e(4, 3).toFixed(10) + "," + d.e(4, 4).toFixed(10), s += ")") : f ? (s = "matrix(", s += d.e(1, 1).toFixed(10) + "," + d.e(1, 2).toFixed(10) + ",", s += d.e(2, 1).toFixed(10) + "," + d.e(2, 2).toFixed(10) + ",", s += d.e(3, 1).toFixed(10) + "px," + d.e(3, 2).toFixed(10) + "px", s += ")") : g && (s = "progid:DXImageTransform.Microsoft.", s += "Matrix(", s += "M11=" + d.e(1, 1).toFixed(10) + ",", s += "M12=" + d.e(1, 2).toFixed(10) + ",", s += "M21=" + d.e(2, 1).toFixed(10) + ",", s += "M22=" + d.e(2, 2).toFixed(10) + ",", s += "SizingMethod='auto expand'", s += ")", b.style.top = d.e(3, 1), b.style.left = d.e(3, 2)), b.style[l] = s }, o = function (b) { return a.fx.step[b] = function (c) { a.cssHooks[b].set(c.elem, c.now + c.unit) }, { get: function (c, d, e) { var f = a(c).data("transforms"); return f === undefined && (f = {}, a(c).data("transforms", f)), f[b] || m[b].defaultValue }, set: function (c, d) { var e = a(c).data("transforms"); e === undefined && (e = {}); var f = m[b]; typeof f.apply == "function" ? e[b] = f.apply(e[b] || f.defaultValue, d) : e[b] = d, a(c).data("transforms", e), n(c) } } }; if (l) for (var p in m) a.cssHooks[p] = o(p), a.cssNumber[p] = !0 } (jQuery)